Ambrosia Comparison with Orleans
=======================================================================

In a nutshell:
-----------
* Ambrosia's big strength is its very strong, performant execution guarantees in the face of failure. Specifically, Ambrosia is the first general purpose distributed programming platform which provides virtual resiliency (see our [whitepaper](https://www.microsoft.com/en-us/research/publication/a-m-b-r-o-s-i-a-providing-performant-virtual-resiliency-for-distributed-applications/)), which insulates developers from the task of writing code to handle a wide variety of failures. Orleans' big strength is its design and implementation of elastic sharding.
* Like Orleans, Ambrosia can communicate effectively with non-Ambrosia components. Unlike Orleans, Ambrosia is a peer-to-peer system, which runs on communicating clients, servers in the cloud, and servers not in the cloud. Globally reliable execution is automatically achieved by Ambrosia amongst communicating Ambrosia components (called Immortals).
* While Ambrosia's first supported language is C#, its design is fundamentally language agnostic, and we will be implementing bindings to other languages, all of which can interoperate. Orleans only supports .NET.
* Ambrosia automatically supports the ability to go back in time and debug Ambrosia Immortals with an attached debugger. Orleans doesn't.
* Ambrosia supports high availability through a deployment time decision to run an Immortal in an active/active configuration. This capability is automatically enabled for every Ambrosia Immortal. Orleans enables high availability through fine grained relocatability of grain state, potentially with significant developer effort and performance consequences (see Protected Execution Guarantees below).
* Orleans' and Ambrosia's strengths are orthogonal, and over time, we intend to bring Orleans' strengths into Ambrosia. Specifically, the programmer model of grains for elastic shardability is a powerful, successful concept. Our implementation, however, will look quite different, as we want to preserve the very high performance Ambrosia achieves while providing its very strong reliability guarantees. In the meantime, with our execution guarantees, our customers have found it straightforward to implement non-elastic sharding through the use of multiple communicating Immortals (see our [whitepaper](https://www.microsoft.com/en-us/research/publication/a-m-b-r-o-s-i-a-providing-performant-virtual-resiliency-for-distributed-applications/)). Some frameworks are even starting to develop implementations of elastic sharding on top of Ambrosia (e.g. Reactive Machine).

In more depth:
-----------

### Protected Execution Guarantees
Fundamentally, Ambrosia is a peer to peer distributed system of components, called Immortals, which, in addition to providing strong guarantees within an Immortal, also provides strong guarantees between Immortals. Let's consider each of these types of guarantees separately, and compare them to Orleans' behavior.

### Guarantees within an Immortal
Ambrosia automatically logs a combination of input, and non-deterministic choices made by the application. This log provides deterministic replayability, which is used to automatically provide fully recoverable computation, high availability through active/active hot standbys, and the ability to debug Immortals by exactly reproducing logged execution in a debugger. In order to be able to clean up portions of the log no longer needed for recovery, Ambrosia also periodically checkpoints the state of Immortals. 

In C#, to support the above strategy, the programmer has 2 added responsibilities, compared to completely ignoring the possibility of failure, to author an Immortal. Immortal writers must inform Ambrosia of non-deterministic choices, and provide a way to serialize Immortal state. In C#, we use data contract serializable interfaces, like Orleans. Non-deterministic choices are delivered to Ambrosia through the use of special method calls called Impulses. 

For instance, Client2 in HelloWorld collects user input, which is not deterministically replayable (i.e. no one is sitting at the keyboard during recovery waiting to reenter their input), and delivers the input to Ambrosia through the ReceiveKeyboardInput method, which is labeled an Impulse. State changes to the Immortal are then performed in the code for ReceiveKeyboardInput, which is executed after the call has been logged. In this manner, non-deterministic choices are communicated by Immortal authors to the Ambrosia runtime, ensuring deterministic replay. Note that there is no need to instruct the system to take checkpoints, or to push information to distributed storage for the purpose of durability.

In contrast, when developers want a high level of robustness in Orleans, they must be careful both in the use of grain checkpointing, and in their interaction with other components, even if these other components are implemented in Orleans, to ensure idempotent, exactly once behavior. Even just considering the checkpointing aspect of Orleans' persistence story, our experiments in our [whitepaper](https://www.microsoft.com/en-us/research/publication/a-m-b-r-o-s-i-a-providing-performant-virtual-resiliency-for-distributed-applications/) indicate that Orleans' fine-grained approach to state persistence will likely be vastly outperformed by Ambrosia (experimental contribution opportunity). Of course some or all of this added complexity and cost could be avoided if lesser levels of reliability are acceptable, with the expected caveats about application behavior.

### Guarantees between components:
Ambrosia automatically keeps track of sequence numbers for method invocations between Immortals, and uses these, along with its recovery log, to ensure transparent recovery and replica failover. There is NO work on the part of the Immortal developer to get this behavior between Immortals. For instance, there is no need to write any durable queuing/sequence # recovery logic/retry code to handle uncertain/partial executions. Of course, work similar to what is required in Orleans may be required to interact with non-Immortals. While Ambrosia is not limited in any way compared to Orleans in its ability to communicate effectively with other non-Ambrosia distributed components/services, it should be clear that there are significant complexity and performance benefits in making as many of your components Immortals as possible.

In contrast, to achieve full failure resiliency, an Orleans developer would have to implement retry on either the client or an intermediary to ensure a method call reaches an Orleans grain. In addition, partial method executions with multiple side effects (even if they're interactions with other Orleans services), would need to leave 'breadcrumbs' to ensure idempotence on retry. Finally, the state of an Orleans grain itself would need to be persisted in order to ensure that the impact of state changing method invocations aren't lost. In summary, a tenable way to achieve a similar level of reliability with Orleans would be to ingress all method invocations into a durable queue, like Kafka or EventHub, introduce an intermediary to pump invocations into Orleans, and carefully implement method logic to handle partial executions and state persistence (through the Orleans grain checkpointing facility). Again, our [whitepaper](https://www.microsoft.com/en-us/research/publication/a-m-b-r-o-s-i-a-providing-performant-virtual-resiliency-for-distributed-applications/) evaluates a similar architecture, and concludes that such an implementation would be orders of magnitude more expensive than Ambrosia, and require significantly more coding and deployment effort. 

