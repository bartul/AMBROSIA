// Generated consumer-side API for the 'server' Ambrosia Node instance.
// Note: This file was generated
// Note: You can edit this file, but to avoid losing your changes be sure to specify a 'mergeType' other than 'None' (the default is 'Annotate') when re-running emitTypeScriptFile[FromSource]().
import Ambrosia = require("ambrosia-node");
import IC = Ambrosia.IC;

let DESTINATION_INSTANCE_NAME: string = "server";
let POST_TIMEOUT_IN_MS: number = 8000; // -1 = Infinite

export namespace Test
{
    export async function OneLineNoCommentAsync(): Promise<void>
    {
        let postResult: void = await IC.postAsync(DESTINATION_INSTANCE_NAME, "OneLineNoComment", 1, null, POST_TIMEOUT_IN_MS);
        return (postResult);
    }

    export function OneLineNoComment(resultHandler: IC.PostResultHandler<void>): void
    {
        IC.post(DESTINATION_INSTANCE_NAME, "OneLineNoComment", 1, resultHandler, POST_TIMEOUT_IN_MS);
    }

    /** Multi Line with Comment before Tag
     * but still before tag
     */
    export async function MultiLineCommentBeforeTagAsync(): Promise<void>
    {
        let postResult: void = await IC.postAsync(DESTINATION_INSTANCE_NAME, "MultiLineCommentBeforeTag", 1, null, POST_TIMEOUT_IN_MS);
        return (postResult);
    }

    /** Multi Line with Comment before Tag
     * but still before tag
     */
    export function MultiLineCommentBeforeTag(resultHandler: IC.PostResultHandler<void>): void
    {
        IC.post(DESTINATION_INSTANCE_NAME, "MultiLineCommentBeforeTag", 1, resultHandler, POST_TIMEOUT_IN_MS);
    }

    export async function MultiSeparateLinesCommentBeforeTagAsync(): Promise<void>
    {
        let postResult: void = await IC.postAsync(DESTINATION_INSTANCE_NAME, "MultiSeparateLinesCommentBeforeTag", 1, null, POST_TIMEOUT_IN_MS);
        return (postResult);
    }

    export function MultiSeparateLinesCommentBeforeTag(resultHandler: IC.PostResultHandler<void>): void
    {
        IC.post(DESTINATION_INSTANCE_NAME, "MultiSeparateLinesCommentBeforeTag", 1, resultHandler, POST_TIMEOUT_IN_MS);
    }

    /************** Have a space after the tag before function declaration
     */
    export async function EmptyLineBetweenTagAndFctnAsync(): Promise<void>
    {
        let postResult: void = await IC.postAsync(DESTINATION_INSTANCE_NAME, "EmptyLineBetweenTagAndFctn", 1, null, POST_TIMEOUT_IN_MS);
        return (postResult);
    }

    /************** Have a space after the tag before function declaration
     */
    export function EmptyLineBetweenTagAndFctn(resultHandler: IC.PostResultHandler<void>): void
    {
        IC.post(DESTINATION_INSTANCE_NAME, "EmptyLineBetweenTagAndFctn", 1, resultHandler, POST_TIMEOUT_IN_MS);
    }

    /****** Spacing around the tag
     */
    export async function SpacingAroundTagAsync(): Promise<void>
    {
        let postResult: void = await IC.postAsync(DESTINATION_INSTANCE_NAME, "SpacingAroundTag", 1, null, POST_TIMEOUT_IN_MS);
        return (postResult);
    }

    /****** Spacing around the tag
     */
    export function SpacingAroundTag(resultHandler: IC.PostResultHandler<void>): void
    {
        IC.post(DESTINATION_INSTANCE_NAME, "SpacingAroundTag", 1, resultHandler, POST_TIMEOUT_IN_MS);
    }

    /** JS Doc
     */
    export async function JSDOcTagAsync(): Promise<void>
    {
        let postResult: void = await IC.postAsync(DESTINATION_INSTANCE_NAME, "JSDOcTag", 1, null, POST_TIMEOUT_IN_MS);
        return (postResult);
    }

    /** JS Doc
     */
    export function JSDOcTag(resultHandler: IC.PostResultHandler<void>): void
    {
        IC.post(DESTINATION_INSTANCE_NAME, "JSDOcTag", 1, resultHandler, POST_TIMEOUT_IN_MS);
    }
}