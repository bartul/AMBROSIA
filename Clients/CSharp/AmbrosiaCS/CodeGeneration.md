# Code Generation

AMBROSIA's C# client makes use of T4 template-based code generation to create an AMBROSIA wrapper for each method in the user-defined APIs.

## Running Code Generation

Once your C# APIs are defined, you can run code generation in the following way:

```shell
Usage: AmbrosiaCS.exe CodeGen [OPTIONS]                                      
Options:                                                                     
  -a, --assembly=VALUE       An input assembly file location. [REQUIRED]     
  -o, --outputAssemblyName=VALUE                                             
                             An output assembly name. [REQUIRED]             
  -f, --targetFramework=VALUE                                                
                             The output assembly target framework. [> 1      
                               REQUIRED]                                     
  -p, --project=VALUE        An input project file location for reference    
                               resolution.                                   
  -h, --help                 show this message and exit                      
```

The command above would output a C# project named <outputAssemblyName>.csproj under 

```shell
GeneratedSourceFiles/<outputAssemblyName>/latest/
```

Any historical generated files under that directory would be moved to a <random> directory under the parent path, creating a history directory that can be sorted by creation date.

Now you can add a project reference to each of your API implementation projects:

```xml
<ItemGroup>
    <ProjectReference Include="..\GeneratedSourceFiles\<outputAssemblyName>\latest\<outputAssemblyName>.csproj" />
</ItemGroup>
```

Since the path to the most recent generated project is static, you would not need to change your reference each time you run code generation.

## Code Generation Deep Dive

### Generating the .csproj file

AmbrosiaCS.exe parses both AmbrosiaCS.csproj and any other .csproj file given to it as a command-line parameter (-p=<projectFile>), if any are given.

The code then extracts any project references or package references from these csproj files and copies them over to the new generated <outputAssemblyName>.csproj. 

All references would be copied over to the new .csproj file. However, if two different versions of the same package exist - a warning message would be outputted to console.

The generated project's target frameworks are copied over from AmbrosiaCS.csproj.

### Generating the code

AmbrosiaCS.exe dynamically loads all assemblies given to it as command-line parameters (-a=<assembly>).

For each interface defined, 3 different .cs files would be generated using T4 template-based code generation.

#### ProxyInterfacesGenerator.tt

*Generates ProxyInterfaces_<InterfaceName>*.cs

The ProxyInterfacesGenerator template creates the AMBROSIA interface that wraps the user-defined interface. 

For each method **Foo**(...) in the user-defined interface, this template would generate an interface containing the following method declarations:

| Generated method                                             | Purpose                          | Condition                                                |
| ------------------------------------------------------------ | -------------------------------- | -------------------------------------------------------- |
| void **Foo**Fork(...)                                        | Fire-and-forget calls to **Foo** | Generated only if **Foo**'s return type is void          |
| Task\<T> **Foo**Async(...) (or Task **Foo**Async(...) if T is void) | Awaitable calls to **Foo**       | Generated only if **Foo** is not defined as an *Impulse* |

*Note: ProxyInterfacesGenerator template also generates a copy of the original user-defined interface. This is for convenience purposes.*

#### ProxyGenerator.tt

*Generates Proxy_<InterfaceName>.cs*

The ProxyGenerator template generates an implementation for the AMBROSIA interfaces generated by ProxyInterfaceGenerator.tt.

##### FooFork(...) Implementation

The implementation of **Foo**Fork simply generates the RPC call that will result in the dispatching of the method **Foo** on the receiving Immortal, sends it and returns.

##### FooAsync(...) Implementation

The implementation of **Foo**Async generates the RPC call that will result in the dispatching of the method **Foo** on the receiving Immortal, sends it and awaits on a TaskCompletionSource that will signal the call completion. If **Foo**'s return value is different than null this TaskCompletionSource object would also return a result, which would in turn be returned by **Foo**Async. 

*Note: The implementation of **Foo**Async also contains portions related to checkpointing. This logic is explained in further detail in the Immortal documentation.*

#### DispatcherGenerator.tt

*Generates Dispatcher_<InterfaceName>.cs*

The DispatcherGenerator template generates an implementation for the abstract class Immortal.Dispatcher for each user-generated interface. The overriden method, DispatchToMethod, handles the dispatching of incoming RPC requests to the appropriate methods in the user code. In case of an async method with a return type, it also handles sending the result back to the RPC sender.

In addition to the 3 aforementioned templates which generate a .cs file for each interface in the inputted assemblies, there is one more template which is generated only once:

#### ImmortalSerializerGenerator.tt 

*Generates ImmortalSerializer.cs*

The ImmortalSerializerGenerator template gets the generated types of proxies and proxy interfaces (generated by ProxyGenerator.tt and ProxyInterfacesGenerator.tt) and produces a serializer for the Immortal class which has these new types defined as KnownTypes.